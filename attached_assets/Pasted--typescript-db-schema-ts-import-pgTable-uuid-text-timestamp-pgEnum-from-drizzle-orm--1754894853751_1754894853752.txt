```typescript
// db/schema.ts
import { pgTable, uuid, text, timestamp, pgEnum } from 'drizzle-orm/pg-core';
import { eq, desc } from 'drizzle-orm';
import { schools } from './schools';

export const planEnum = pgEnum('plan', ['TRIAL', 'BASIC', 'SMALL', 'MEDIUM', 'LARGE', 'UNLIMITED']);

export const subscriptionEvents = pgTable('subscription_events', {
  id: uuid('id').defaultRandom().primaryKey(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  schoolId: uuid('school_id').notNull().references(() => schools.id, { onDelete: 'cascade' }),
  event: text('event').notNull(),
  previousPlan: planEnum('previous_plan'),
  newPlan: planEnum('new_plan'),
  stripeSubId: text('stripe_sub_id'),
});

// server/adminRoutes.ts
app.patch('/api/admin/schools/:id', requireAdmin, async (req, res) => {
  const { plan, status, seats, notes, periodEnd, trialEnd } = req.body;
  await db.update(schools).set({
    ...(plan ? { plan } : {}),
    ...(status ? { status } : {}),
    ...(seats !== undefined ? { seats } : {}),
    ...(notes !== undefined ? { notes } : {}),
    ...(periodEnd ? { periodEnd: new Date(periodEnd) } : {}),
    ...(trialEnd ? { trialEnd: new Date(trialEnd) } : {}),
    updatedAt: new Date(),
  }).where(eq(schools.id, req.params.id));
  res.json({ ok: true });
});

app.get('/api/admin/events', requireAdmin, async (_req, res) => {
  const rows = await db.select().from(subscriptionEvents).orderBy(desc(subscriptionEvents.createdAt)).limit(500);
  res.json(rows);
});

// stripeWebhook handler adjustments
if (event.type === 'checkout.session.completed' || event.type === 'customer.subscription.updated') {
  const sub = await stripe.subscriptions.retrieve(subId);
  const newPlanCode = planFromStripePrice(sub.items.data[0].price.id);
  const periodEnd = new Date((sub.current_period_end || 0) * 1000);
  const trialEnd = sub.trial_end ? new Date(sub.trial_end * 1000) : null;
  const currentSchool = await db.query.schools.findFirst({ where: eq(schools.stripeSubId, sub.id) });
  if (currentSchool && currentSchool.plan !== newPlanCode) {
    await db.insert(subscriptionEvents).values({
      schoolId: currentSchool.id,
      event: 'PLAN_UPDATED',
      previousPlan: currentSchool.plan,
      newPlan: newPlanCode,
      stripeSubId: sub.id,
    });
  }
  await db.update(schools).set({
    plan: newPlanCode,
    periodEnd,
    trialEnd,
    updatedAt: new Date(),
  }).where(eq(schools.id, currentSchool.id));
}
```

**Final Go Checklist**
1. **planFromStripePrice** → Implement mapping from Stripe price IDs to your internal plan enum.
2. **periodEnd / trialEnd fields** → Confirm these columns exist in your canonical `schools` table definition (and database).
3. **Indexes** → Add indexes on `subscription_events.created_at` and `subscription_events.school_id`.
4. **Validation** → Add validation for `plan` and `status` in the PATCH route.

If all four are complete, the code is ready for deployment.
