the healthcheck is failing because your app is crashing on start:

TypeError [ERR_INVALID_ARG_TYPE]: The "paths[0]" argument must be of type string. Received undefined
    at Object.resolve (node:path:1097:7)
    at file:///app/dist/index.js:1907:17


That means somewhere we’re doing path.resolve(<something undefined>). Easiest fix: remove any custom static-serving helper and use a tiny, bulletproof production block that logs the exact paths it uses.

Paste this minimal, safe server/index.ts (it keeps Stripe-first, adds early health, and serves the built client from dist/ only in prod). It does not call serveStatic(app) so nothing else can pass undefined to path.resolve.

// ==== env first ====
import { ENV, isProduction } from "./env";

import express, { type Request, Response, NextFunction } from "express";
import cookieParser from "cookie-parser";
import { registerRoutes } from "./routes";
import { registerV2Routes } from "./routes/register-v2";
import { setupVite, log } from "./vite";
import "./passResetScheduler";
import { registerStripeWebhook } from "./stripe/webhook-v2";

import path from "path";
import fs from "fs";
import { fileURLToPath } from "url";

// ESM friendly __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
app.set("trust proxy", 1);

// --- EARLY health route so healthcheck never 404s even if later code errors
app.get("/api/health", (_req, res) => res.status(200).json({ status: "ok" }));
app.get("/api/healthz", (_req, res) => res.type("text/plain").send("ok"));

// --- Stripe webhook FIRST (raw body inside the function)
registerStripeWebhook(app);

// --- normal parsers ---
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser(ENV.SESSION_SECRET));

// --- tiny API logger ---
app.use((req, res, next) => {
  const t = Date.now();
  res.on("finish", () => {
    if (req.path.startsWith("/api")) log(`${req.method} ${req.path} ${res.statusCode} ${Date.now()-t}ms`);
  });
  next();
});

(async () => {
  // API routes
  const server = await registerRoutes(app);
  registerV2Routes(app);

  // API error -> JSON
  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    res.status(status).json({ message: err.message || "Internal Server Error" });
    throw err;
  });

  const prod = isProduction() || process.env.REPLIT_DEPLOYMENT === "1";
  log(`NODE_ENV=${ENV.NODE_ENV} prod=${prod}`);

  if (!prod) {
    log("Vite dev middleware");
    await setupVite(app, server);
  } else {
    // ===== Production static serving (no helpers, no ENV paths) =====
    // __dirname points to /app/dist at runtime since we run node dist/index.js
    const clientDir = path.resolve(__dirname, "./"); // dist/
    const indexPath = path.join(clientDir, "index.html");

    log(`clientDir=${clientDir}`);
    log(`index exists=${fs.existsSync(indexPath)}`);

    // No-cache for index.html so new deploys show immediately
    app.use((req, res, next) => {
      if (req.path === "/" || req.path.endsWith("/index.html")) {
        res.set("Cache-Control", "no-cache, no-store, must-revalidate, max-age=0");
      }
      next();
    });

    // Serve static assets
    app.use(express.static(clientDir));

    // SPA fallback (do not capture /api/*)
    app.get("*", (req, res, next) => {
      if (req.path.startsWith("/api/")) return next();
      if (!fs.existsSync(indexPath)) return res.status(500).send("index.html missing in dist/");
      return res.sendFile(indexPath);
    });
  }

  // ---- Start server on Railway-assigned port ----
  const port = Number(process.env.PORT || 8080);
  server.listen(
    { port, host: "0.0.0.0", reusePort: true },
    () => log(`serving on port ${port}`)
  );
})();

Make sure these are set in Railway

Variables:

PORT=8080

NODE_ENV=production

SESSION_SECRET=<32 chars>

Anything your env.ts requires (use dummy non-empty values if you’re not using the integration yet):
DATABASE_URL, STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, SENDGRID_API_KEY, etc.

Build/Run:

Build: npm ci && npm run build

Start: npm run start

Healthcheck path: /api/health

Why this will pass

We removed any call that could pass undefined into path.resolve.

We log clientDir and whether index.html exists; if it’s false, Vite isn’t writing to dist/—then set outDir: "dist" in vite.config.ts or tell me where it writes and I’ll adjust clientDir.

Health endpoint is registered before everything else so Railway always gets a 200 if the process is alive.