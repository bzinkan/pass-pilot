The crash happens before the server starts while evaluating your bundled file:

TypeError [ERR_INVALID_ARG_TYPE]: The "paths[0]" argument must be of type string. Received undefined
 at Object.resolve (node:path:1097:7)
 at file:///app/dist/index.js:1907:17


That almost always means some import that runs at module-load time is doing path.resolve(undefined). In your project, the likely culprit is ./vite (your helper) getting imported at the top—it probably references a path/env during module init.

Fix: don’t import ./vite at the top in production

Load it only in dev (dynamic import). Also remove any dependency on serveStatic and serve the built client with a tiny, safe block.

Paste this minimal server/index.ts (no top-level ./vite import, own log()):

// ==== env first ====
import { ENV, isProduction } from "./env";

import express, { type Request, Response, NextFunction } from "express";
import cookieParser from "cookie-parser";
import { registerRoutes } from "./routes";
import { registerV2Routes } from "./routes/register-v2";
import "./passResetScheduler";
import { registerStripeWebhook } from "./stripe/webhook-v2";

import path from "path";
import fs from "fs";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// tiny logger (avoids importing ./vite at module load)
const log = (...args: any[]) => console.log("[app]", ...args);

const app = express();
app.set("trust proxy", 1);

// Early health so healthcheck never 404s if later code crashes
app.get("/api/health", (_req, res) => res.status(200).json({ status: "ok" }));
app.get("/api/healthz", (_req, res) => res.type("text/plain").send("ok"));

// Stripe webhook FIRST (raw body inside registration)
registerStripeWebhook(app);

// Normal parsers
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser(ENV.SESSION_SECRET));

// Light API log
app.use((req, res, next) => {
  const t = Date.now();
  res.on("finish", () => {
    if (req.path.startsWith("/api"))
      log(`${req.method} ${req.path} ${res.statusCode} ${Date.now() - t}ms`);
  });
  next();
});

(async () => {
  const server = await registerRoutes(app);
  registerV2Routes(app);

  // API error handler
  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    res.status(status).json({ message: err.message || "Internal Server Error" });
    throw err;
  });

  const prod = isProduction() || process.env.REPLIT_DEPLOYMENT === "1";
  log(`NODE_ENV=${ENV.NODE_ENV} prod=${prod}`);

  if (!prod) {
    // Dev: dynamically import vite helper ONLY in dev
    const { setupVite } = await import("./vite");
    log("Vite dev middleware");
    await setupVite(app, server);
  } else {
    // Prod: serve built client directly from dist/
    const clientDir = path.resolve(__dirname, "./"); // dist/ at runtime
    const indexPath = path.join(clientDir, "index.html");

    log(`clientDir=${clientDir}`);
    log(`index exists=${fs.existsSync(indexPath)}`);

    app.use((req, res, next) => {
      if (req.path === "/" || req.path.endsWith("/index.html")) {
        res.set("Cache-Control", "no-cache, no-store, must-revalidate, max-age=0");
      }
      next();
    });

    app.use(express.static(clientDir));

    app.get("*", (req, res, next) => {
      if (req.path.startsWith("/api/")) return next();
      if (!fs.existsSync(indexPath)) return res.status(500).send("index.html missing in dist/");
      return res.sendFile(indexPath);
    });
  }

  const port = Number(process.env.PORT || 8080);
  server.listen({ port, host: "0.0.0.0", reusePort: true }, () => log(`serving on port ${port}`));
})();

Why this works

We removed any top-level import of ./vite that could call path.resolve with an undefined argument during module evaluation.

Production static serving uses only __dirname (which is dist/ when running node dist/index.js)—no env-based paths.

We log clientDir and whether index.html exists so the next logs will immediately tell us if Vite’s output dir mismatches.