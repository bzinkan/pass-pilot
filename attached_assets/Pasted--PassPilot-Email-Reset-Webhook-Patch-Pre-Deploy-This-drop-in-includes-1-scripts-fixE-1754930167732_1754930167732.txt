# PassPilot — Email Reset + Webhook Patch (Pre‑Deploy)

This drop-in includes:

1. `scripts/fixEmailReset.ts` — **safe, dry‑run by default** utility to purge a reused test email from your DB rows (users, sessions) and clear any stale Stripe IDs on the linked school(s). Use `--apply` to actually modify rows.
2. `stripe/webhooks.patch.ts` — strong lookup by **subscription/customer IDs**, not email. Explicit Price→Plan mapping, and guardrails to avoid reviving old plans.
3. `routes/api/checkout/success.ts` — change redirect to **/app** to avoid the login limbo.
4. (Optional) Login page safety shim to auto-forward to **/app** when a valid `pp_session` exists.
5. Pre‑deploy unit test snippet to simulate reusing an email twice.

> Adjust table and column names if your schema differs. The code assumes:
>
> * `users(id, email, schoolId, passwordHash, createdAt)`
> * `sessions(id, userId, createdAt)`
> * `schools(id, name, plan, stripeCustomerId, stripeSubscriptionId)`
> * ON DELETE CASCADE is already enforced for child rows.

---

## 1) `scripts/fixEmailReset.ts`

```ts
// scripts/fixEmailReset.ts
// Usage:
//   ts-node scripts/fixEmailReset.ts zinkan.brian@gmail.com        # dry-run
//   ts-node scripts/fixEmailReset.ts zinkan.brian@gmail.com --apply # actually mutate
//
// Requires DRIZZLE DB client setup (import from your db/index).

import 'dotenv/config';
import { eq, and } from 'drizzle-orm';
import { db } from '../db'; // <-- your db connector
import { users } from '../db/schema/users';
import { sessions } from '../db/schema/sessions';
import { schools } from '../db/schema/schools';

function norm(e: string) { return e.trim().toLowerCase(); }

async function main() {
  const raw = process.argv[2];
  const apply = process.argv.includes('--apply');
  if (!raw) {
    console.error('Provide an email to reset.');
    process.exit(1);
  }
  const email = norm(raw);
  console.log(`\n[fixEmailReset] Target email: ${email}`);
  console.log(`[fixEmailReset] Mode: ${apply ? 'APPLY (will change data)' : 'DRY-RUN (no changes)'}\n`);

  // 1) Find all users matching email
  const foundUsers = await db.select().from(users).where(eq(users.email, email));
  if (foundUsers.length === 0) {
    console.log('No users found for that email.');
  } else {
    console.log(`Found ${foundUsers.length} user(s):`);
    foundUsers.forEach(u => console.log(` - user.id=${u.id} schoolId=${u.schoolId}`));

    // 2) List related sessions (child rows)
    for (const u of foundUsers) {
      const sess = await db.select().from(sessions).where(eq(sessions.userId, u.id));
      console.log(`   user ${u.id} has ${sess.length} session(s)`);
      if (apply && sess.length) {
        await db.delete(sessions).where(eq(sessions.userId, u.id));
      }
    }

    // 3) Delete the users (CASCADE will clear more, if configured)
    if (apply) {
      for (const u of foundUsers) {
        await db.delete(users).where(eq(users.id, u.id));
      }
      console.log(`Deleted ${foundUsers.length} user(s).`);
    }
  }

  // 4) Find any schools tied to this email as an *only* admin (best-effort).
  // If your model tracks roles, you can refine this to only admins.
  const candidateSchools = await db.select().from(schools)
    .where(eq(schools.stripeCustomerId, email as unknown as string)) as any[];
  // ^ If you do not store email in schools, comment out the above. We keep it to catch legacy data.

  if (candidateSchools?.length) {
    console.log(`\nPotential legacy link(s) on schools via email field: ${candidateSchools.length}`);
    for (const s of candidateSchools) {
      console.log(` - school.id=${s.id} plan=${s.plan} customerId=${s.stripeCustomerId} subId=${s.stripeSubscriptionId}`);
      if (apply) {
        await db.update(schools)
          .set({ stripeCustomerId: null, stripeSubscriptionId: null })
          .where(eq(schools.id, s.id));
      }
    }
  }

  // 5) Extra: If your webhooks previously looked up by email, clear those stale IDs.
  // Prefer manual review in Stripe dashboard (test mode) to cancel old subs for this testing email.

  console.log('\n[fixEmailReset] Done.');
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
```

> If your schema never stores email on `schools`, remove the legacy `candidateSchools` block — it’s included to clean up older data where email might have been stashed.

---

## 2) `stripe/webhooks.patch.ts` (lookup by IDs, not email)

```ts
// server/stripe/webhooks.patch.ts
// Mount at POST /api/stripe/webhook with raw body parsing per Stripe docs.

import Stripe from 'stripe';
import type { Request, Response } from 'express';
import { db } from '../../db';
import { schools } from '../../db/schema/schools';
import { eq } from 'drizzle-orm';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-06-20',
});

const PRICE_TO_PLAN: Record<string, 'TRIAL'|'BASIC'|'SMALL'|'MEDIUM'|'LARGE'|'UNLIMITED'> = {
  'price_trial_xxx': 'TRIAL',
  'price_teacher_monthly_xxx': 'BASIC', // map to your enum
  // ... add the rest
};

function mapLineToPlan(priceId?: string | null) {
  if (!priceId) return null;
  return PRICE_TO_PLAN[priceId] ?? null;
}

export async function handleStripeWebhook(req: Request, res: Response) {
  const sig = req.headers['stripe-signature'] as string;
  let event: Stripe.Event;
  try {
    event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET!);
  } catch (err) {
    return res.status(400).send(`Webhook Error: ${(err as Error).message}`);
  }

  switch (event.type) {
    case 'checkout.session.completed': {
      const session = event.data.object as Stripe.Checkout.Session;
      const subscriptionId = (session.subscription as string) || null;
      const customerId = (session.customer as string) || null;

      if (!subscriptionId || !customerId) break;

      // Attach IDs to the school you just created during signup. You should
      // pass a schoolId in session metadata from your checkout creation step.
      const schoolId = session.metadata?.schoolId;
      if (!schoolId) break; // log and investigate

      await db.update(schools)
        .set({ stripeCustomerId: customerId, stripeSubscriptionId: subscriptionId })
        .where(eq(schools.id, schoolId));
      break;
    }

    case 'customer.subscription.updated':
    case 'customer.subscription.created': {
      const sub = event.data.object as Stripe.Subscription;
      const subscriptionId = sub.id;
      const priceId = sub.items.data[0]?.price?.id ?? null;
      const plan = mapLineToPlan(priceId);

      // Strong lookup by subscription id
      const [school] = await db.select().from(schools).where(eq(schools.stripeSubscriptionId, subscriptionId));
      if (!school) break; // unknown subscription — ignore

      if (plan) {
        await db.update(schools)
          .set({ plan })
          .where(eq(schools.id, school.id));
      } else {
        // Do not overwrite with stale plan if mapping fails
        // TODO: log warning with subscriptionId & priceId
      }
      break;
    }

    case 'customer.subscription.deleted': {
      const sub = event.data.object as Stripe.Subscription;
      const subscriptionId = sub.id;
      // Mark school back to TRIAL or PAUSED depending on your policy
      const [school] = await db.select().from(schools).where(eq(schools.stripeSubscriptionId, subscriptionId));
      if (school) {
        await db.update(schools)
          .set({ plan: 'TRIAL' })
          .where(eq(schools.id, school.id));
      }
      break;
    }

    default:
      // ignore others
      break;
  }

  res.json({ received: true });
}
```

> Key changes: **No email lookups**. Every mutation finds the school via `stripeSubscriptionId` (or metadata at creation). No more stale plan fallbacks.

---

## 3) `/api/checkout/success` → redirect to `/app`

```ts
// routes/api/checkout/success.ts
app.get('/api/checkout/success', async (req, res) => {
  // ... your existing logic to upsert school/admin + set pp_session cookie
  return res.redirect('/app'); // avoid /login limbo
});
```

---

## 4) (Optional) Login page safety shim

```ts
// In Login component
import { useEffect } from 'react';

useEffect(() => {
  fetch('/api/me', { credentials: 'include' })
    .then(r => { if (r.ok) window.location.href = '/app'; })
    .catch(() => {});
}, []);
```

---

## 5) Pre‑deploy duplicate‑email test (adds to your preDeploy script)

```ts
// scripts/preDeploy-duplicateEmail.spec.ts (optional)
// Pseudo-test to ensure reusing the same email preserves the intended plan transitions
import assert from 'node:assert';

async function run() {
  const TEST_EMAIL = `pp_test_${Date.now()}@example.com`;

  // 1) Register trial -> expect TRIAL
  // .. call your local registration helper; fetch school -> assert plan === 'TRIAL'

  // 2) Re-register SAME email for trial again -> ensure still TRIAL, no stale plan
  // .. call again; fetch school -> assert plan === 'TRIAL'

  console.log('Duplicate-email trial test passed (placeholder).');
}

run().catch(e => { console.error(e); process.exit(1); });
```

---

### Deployment notes

* Add `STRIPE_WEBHOOK_SECRET` to your deploy env.
* Confirm `onDelete: 'cascade'` exists for `sessions.userId -> users.id` and other child tables.
* Price mapping must be accurate for your Stripe Price IDs.

---

**Next actions**

1. Paste these files into Replit.
2. Wire `handleStripeWebhook` at your webhook route.
3. Run `ts-node scripts/fixEmailReset.ts zinkan.brian@gmail.com` (inspect) then with `--apply`.
4. Re‑test the email flow + ensure `/api/checkout/success` lands you on `/app`.
