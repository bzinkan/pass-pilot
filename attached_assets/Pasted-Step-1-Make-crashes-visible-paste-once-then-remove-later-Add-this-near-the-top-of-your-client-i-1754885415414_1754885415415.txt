Step 1 — Make crashes visible (paste once, then remove later)
Add this near the top of your client/index.html (or whatever serves your React root). It replaces the white screen with the actual error text.

html
Copy
Edit
<script>
  window.addEventListener('error', e => {
    document.body.innerHTML =
      '<pre style="padding:16px;font:14px/1.5 monospace;white-space:pre-wrap">JS Error: ' +
      e.message + '\n' + (e.filename||'') + ':' + (e.lineno||'') + '</pre>';
  });
  window.addEventListener('unhandledrejection', e => {
    document.body.innerHTML =
      '<pre style="padding:16px;font:14px/1.5 monospace;white-space:pre-wrap">Promise Rejection: ' +
      (e.reason?.stack || e.reason?.message || String(e.reason)) + '</pre>';
  });
</script>
Also, wrap your app in an Error Boundary so React-side exceptions don’t blank the tree:

tsx
Copy
Edit
// ErrorBoundary.tsx
import React from 'react';
export default class ErrorBoundary extends React.Component<{}, {err?: any}> {
  constructor(p:any){ super(p); this.state={}; }
  static getDerivedStateFromError(err:any){ return { err }; }
  render(){
    if (this.state.err) {
      return <pre style={{padding:16, fontFamily:'monospace', whiteSpace:'pre-wrap'}}>
        {String(this.state.err?.message || this.state.err)}
      </pre>;
    }
    return this.props.children as any;
  }
}

// main.tsx
import ErrorBoundary from './ErrorBoundary';
root.render(
  <ErrorBoundary>
    <App/>
  </ErrorBoundary>
);
Reload. Instead of a white page, you should now see the exact error. Keep that handy—we’ll fix whatever it shows.

Step 2 — Fix the most common cause after login: auth fetch + cookies
When you log in and it goes blank, typically your app does a fetch (e.g., /api/admin/schools) and then crashes because it gets a 401/HTML or empty JSON but your code assumes success.

Do two things:

Make sure every admin fetch includes cookies:

ts
Copy
Edit
const res = await fetch('/api/admin/schools', { credentials: 'include' });
if (!res.ok) throw new Error(`admin/schools ${res.status}`);
const rows = await res.json();
Ensure your server sets the cookie for your https domain:

ts
Copy
Edit
res.cookie('admin', token, {
  httpOnly: true,
  secure: true,          // https only
  sameSite: 'none',      // required when using cross-site contexts/proxies
  path: '/',             // send on all paths
  // domain: 'passpilot.net', // optional; only set if you know you need it
  maxAge: 7*24*60*60*1000
});
If you already did this but still see a 401, render the login instead of crashing:

ts
Copy
Edit
if (res.status === 401) {
  setAuthNeeded(true);   // show <AdminLogin />
  return;
}
Step 3 — Sanity checks that also cause “blank”
Vite env in client: anywhere in browser code you used process.env.X will be undefined in prod and can crash. Use import.meta.env.VITE_* only.

History fallback: your server must serve index.html for all routes (use connect-history-api-fallback). If you hit /admin directly and server 404s the JS, you’ll see blank.

No-cache HTML: serve //index.html with Cache-Control: no-store so you don’t load an HTML that points to missing chunk hashes.

Service worker (even Incognito sometimes reuses profiles on mobile): temporarily comment out SW registration and redeploy once to rule it out.

Step 4 — Quick helper to catch bad JSON responses
Paste this little helper and use it for all critical fetches:

ts
Copy
Edit
async function safeJSON(res: Response) {
  if (!res.ok) {
    const text = await res.text().catch(()=> '');
    throw new Error(`${res.url} -> ${res.status} ${res.statusText}\n${text.slice(0,200)}`);
  }
  const ct = res.headers.get('content-type') || '';
  if (!ct.includes('application/json')) {
    const text = await res.text();
    throw new Error(`Expected JSON from ${res.url}, got:\n${text.slice(0,200)}`);
  }
  return res.json();
}

// usage
const rows = await safeJSON(await fetch('/api/admin/schools', { credentials: 'include' }));