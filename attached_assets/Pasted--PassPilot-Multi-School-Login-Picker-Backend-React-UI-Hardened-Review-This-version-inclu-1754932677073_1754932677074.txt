# PassPilot — Multi‑School Login Picker (Backend + React UI) — Hardened Review

This version includes code‑review fixes for security, correctness, and performance:

* Proper `IN` query for listing only the user’s schools
* Exact lookup when `schoolId` is provided
* Clean `schoolId` typing
* Consistent API shapes
* Session cookie notes
* Optional rate limiting

> Assumes **per‑school users**: `users(id, schoolId, email, passwordHash, role)` and `UNIQUE (school_id, email)`.

---

## 1) Backend — `/api/login` (final)

* If `schoolId` is included → single‑step login into that school
* If not → authenticate password once, then

  * **1 match** → sign in
  * **>1 matches** → return the schools for this email so the client can present a dropdown

```ts
// routes/api/login.ts
import { Router } from 'express';
import bcrypt from 'bcryptjs';
import { db } from '../../db';
import { users } from '../../db/schema/users';
import { schools } from '../../db/schema/schools';
import { and, eq, inArray } from 'drizzle-orm';

export const loginRouter = Router();

function norm(e: string) { return e.trim().toLowerCase(); }

// Helper: issue a session cookie (replace with your signer/serializer)
async function setSession(res: any, payload: { userId: string; schoolId: string }) {
  const value = JSON.stringify(payload);
  res.cookie('pp_session', value, {
    httpOnly: true,
    sameSite: 'lax',
    secure: process.env.NODE_ENV === 'production',
    path: '/',
    maxAge: 1000 * 60 * 60 * 24 * 30,
  });
}

// POST /api/login
// Body: { email, password, schoolId? }
loginRouter.post('/api/login', async (req, res) => {
  try {
    const email = norm(String(req.body?.email || ''));
    const password = String(req.body?.password || '');
    const schoolId = req.body?.schoolId as string | undefined; // keep undefined if not provided

    if (!email || !password) return res.status(400).json({ error: 'Missing email or password' });

    // Single-step login when schoolId is specified
    if (schoolId) {
      const [user] = await db
        .select({ id: users.id, passwordHash: users.passwordHash, schoolId: users.schoolId })
        .from(users)
        .where(and(eq(users.email, email), eq(users.schoolId, schoolId)));

      if (!user) return res.status(401).json({ error: 'Invalid credentials' });
      const ok = await bcrypt.compare(password, user.passwordHash);
      if (!ok) return res.status(401).json({ error: 'Invalid credentials' });

      await setSession(res, { userId: user.id, schoolId: user.schoolId });
      return res.json({ success: true });
    }

    // No schoolId: collect all accounts for this email
    const candidates = await db
      .select({ id: users.id, passwordHash: users.passwordHash, schoolId: users.schoolId })
      .from(users)
      .where(eq(users.email, email));

    if (candidates.length === 0) return res.status(401).json({ error: 'Invalid credentials' });

    // Verify password once (prevents leaking how many accounts exist)
    const firstOk = await bcrypt.compare(password, candidates[0].passwordHash);
    if (!firstOk) return res.status(401).json({ error: 'Invalid credentials' });

    if (candidates.length === 1) {
      const user = candidates[0];
      await setSession(res, { userId: user.id, schoolId: user.schoolId });
      return res.json({ success: true });
    }

    // >1 schools for this email → fetch only those schools for the dropdown
    const schoolIds = candidates.map(c => c.schoolId);
    const schoolRows = await db
      .select({ id: schools.id, name: schools.name })
      .from(schools)
      .where(inArray(schools.id, schoolIds));

    return res.json({ success: false, requiresSchool: true, schools: schoolRows });
  } catch (e) {
    console.error('login error', e);
    return res.status(500).json({ error: 'Unexpected error' });
  }
});
```

**Hardening checklist**

* Ensure `users.email` is indexed
* Enforce `UNIQUE (school_id, email)` on `users`
* `FOREIGN KEY (school_id) REFERENCES schools(id) ON DELETE CASCADE`
* Add rate limiting:

```ts
// example
import rateLimit from 'express-rate-limit';
loginRouter.use(rateLimit({ windowMs: 60_000, max: 20 }));
```

---

## 2) Frontend — Login with dropdown (final)

* Step 1 tries email/password
* If API returns `{ requiresSchool: true }`, render the school picker and re‑POST with `schoolId`

```tsx
// src/pages/Login.tsx
import React, { useEffect, useState } from 'react';

export default function Login() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [requiresSchool, setRequiresSchool] = useState(false);
  const [schools, setSchools] = useState<Array<{ id: string; name: string }>>([]);
  const [schoolId, setSchoolId] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  // Safety shim: if already logged in, go straight to /app
  useEffect(() => {
    fetch('/api/me', { credentials: 'include' })
      .then(r => { if (r.ok) window.location.href = '/app'; })
      .catch(() => {});
  }, []);

  async function submitInitial() {
    setError(''); setLoading(true);
    try {
      const res = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ email, password }),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || 'Login failed');

      if (data.requiresSchool) {
        setRequiresSchool(true);
        setSchools(data.schools || []);
        const first = (data.schools || [])[0];
        setSchoolId(first ? first.id : '');
      } else if (data.success) {
        window.location.href = '/app';
      } else {
        throw new Error('Unexpected response');
      }
    } catch (e: any) {
      setError(e.message || 'Login failed');
    } finally {
      setLoading(false);
    }
  }

  async function submitWithSchool() {
    setError(''); setLoading(true);
    try {
      const res = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ email, password, schoolId }),
      });
      const data = await res.json();
      if (!res.ok || !data.success) throw new Error(data.error || 'Login failed');
      window.location.href = '/app';
    } catch (e: any) {
      setError(e.message || 'Login failed');
    } finally {
      setLoading(false);
    }
  }

  function onKey(e: React.KeyboardEvent<HTMLInputElement | HTMLSelectElement>) {
    if (e.key === 'Enter') {
      if (!requiresSchool) submitInitial();
      else if (schoolId) submitWithSchool();
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center p-6 bg-gray-50">
      <div className="w-full max-w-md bg-white shadow-xl rounded-2xl p-6 space-y-4">
        <h1 className="text-2xl font-semibold text-center">Sign in to PassPilot</h1>

        <label className="block text-sm font-medium">Email</label>
        <input
          className="w-full border rounded-xl px-3 py-2"
          type="email"
          value={email}
          onChange={e => setEmail(e.target.value)}
          onKeyDown={onKey}
          placeholder="you@school.org"
          autoComplete="username"
        />

        <label className="block text-sm font-medium">Password</label>
        <input
          className="w-full border rounded-xl px-3 py-2"
          type="password"
          value={password}
          onChange={e => setPassword(e.target.value)}
          onKeyDown={onKey}
          placeholder="••••••••"
          autoComplete="current-password"
        />

        {requiresSchool && (
          <div className="space-y-1">
            <label className="block text-sm font-medium">Choose your school</label>
            <select
              className="w-full border rounded-xl px-3 py-2"
              value={schoolId}
              onChange={e => setSchoolId(e.target.value)}
              onKeyDown={onKey}
            >
              {schools.map(s => (
                <option key={s.id} value={s.id}>{s.name}</option>
              ))}
            </select>
          </div>
        )}

        {error && <div className="text-sm text-red-600">{error}</div>}

        {!requiresSchool ? (
          <button
            className="w-full rounded-xl py-2 font-medium bg-black text-white disabled:opacity-50"
            onClick={submitInitial}
            disabled={loading}
          >
            {loading ? 'Checking…' : 'Sign in'}
          </button>
        ) : (
          <button
            className="w-full rounded-xl py-2 font-medium bg-black text-white disabled:opacity-50"
            onClick={submitWithSchool}
            disabled={loading || !schoolId}
          >
            {loading ? 'Signing in…' : 'Continue'}
          </button>
        )}

        <p className="text-xs text-gray-500 text-center">
          If this email belongs to multiple schools, pick the right one above.
        </p>
      </div>
    </div>
  );
}
```

---

## 3) Testing checklist

* One account with a single school → login should go straight to `/app`.
* Same email added to a second school → login should prompt for school selection and work for each choice.
* Wrong password → always `401 { error: 'Invalid credentials' }` (no school list shown).
* Session‑based `/api/me` should reflect the chosen `schoolId`.

---

## 4) Pre‑Deploy static check (optional)

Add to `preDeploy.js` to confirm the multi‑school response branch is present:

```js
results.push(await step('Login supports multi-school flow (static)', async () => {
  const fs = require('fs');
  const path = require('path');
  const file = ['routes/api/login.ts','server/routes/api/login.ts'].map(f => path.resolve(process.cwd(), f)).find(p => fs.existsSync(p));
  if (!file) { console.log('⚠️  login route not found for static check'); return; }
  const src = fs.readFileSync(file, 'utf8');
  if (!src.includes('requiresSchool')) throw new Error('Multi-school logic missing in /api/login');
});
```

---

### Notes

* If you later migrate to **global users + memberships**, this UI still works — `/api/login` would just return memberships instead of per‑school user rows.
* Keep using the registration **school uniqueness guard** to prevent duplicate tenants.
